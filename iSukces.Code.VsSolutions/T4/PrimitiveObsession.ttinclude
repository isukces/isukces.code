<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
// This file was generated by iSukces.Templates ver 1.25.1021.7
// Get latest version from https://raw.githubusercontent.com/isukces/iSukces.Templates/main/Code/iSukces.Templates/PrimitiveObsession.ttinclude
<#+
#nullable enable

public static class Config
{
    public static string          Namespace       { get; set; } = "NoNamespace";
    public static Features        IgnoreFeatures  { get; set; }
    public static Features        IncludeFeatures { get; set; }
    public static HashSet<string> ImplicitUsings  { get; } = new();
    /// <summary>
    ///     Default conversion to primitive type
    /// </summary>
    public static TypeConversion ConvertToPrimitive { get; set; } = TypeConversion.Explicit;
    /// <summary>
    ///     Default conversion from primitive type
    /// </summary>
    public static TypeConversion ConvertFromPrimitive { get; set; } = TypeConversion.Explicit;
    /// <summary>
    ///     Default ToString method expression
    /// </summary>
    public static string? ToStringExpression { get; set; } 
}

[Flags]
public enum Features
{
    None                            = 0,
    PrimitiveWrapper                = 1,
    Comparable                      = 2,
    ComparablePrimitive             = 4,
    EquatablePrimitive              = 8,
    ImplicitConversionToPrimitive   = 16,
    ImplicitConversionFromPrimitive = 32,
    RelativeOperators               = 64,
    EqualityOperators               = 128,
    ComparableObject                = 256,
    NewtonsoftJsonSerializer        = 512,
    SystemTextJsonSerializer        = 1024,
    Parse                           = 2048,
    All                             = 4095
}

public enum TypeConversion
{
    None,
    Implicit,
    Explicit
}

public sealed class CaseExpressionItem(string condition, string value)
{
    public string Condition { get; } = condition;
    public string Value     { get; } = value;
}

public class CodeWriterBase
{
    protected void CheckArgumentNullOrEmpty(string argumentName)
    {
        SingleLineIf($"string.IsNullOrEmpty({argumentName})",
            "throw new ArgumentException(\"\", nameof(" + argumentName + "));");
    }

    public CodeWriterBase Close(bool addNl, string append = "")
    {
        DecIndent();
        WriteLine("}" + append);
        if (addNl)
            WriteLine();
        return this;
    }

    public CodeWriterBase DecIndent()
    {
        if (_indent < 1)
            throw new InvalidOperationException("Indent is already 0");
        _indent--;
        return UpdateIndent();
    }

    public CodeWriterBase IncIndent()
    {
        _indent++;
        return UpdateIndent();
    }

    protected CodeWriterBase Open(string x)
    {
        if (!string.IsNullOrEmpty(x))
            WriteLine(x);
        WriteLine("{");
        IncIndent();
        return this;
    }

    protected CodeWriterBase SingleLineIf(string condition, string statement)
    {
        WriteLine("if (" + condition + ")");
        IncIndent();
        WriteLine(statement);
        DecIndent();
        return this;
    }

    private CodeWriterBase UpdateIndent()
    {
        IndentString = _indent > 0 ? new string(' ', _indent * 4) : "";
        return this;
    }

    protected void WriteCaseExpressionStatement(string open, IEnumerable<CaseExpressionItem> get1, string appendClose)
    {
        Open(open);
        var lines = get1.ToArray();
        for (var index = 0; index < lines.Length; index++)
        {
            var item  = lines[index];
            var comma = index == lines.Length - 1 ? "" : ",";
            WriteLine($"{item.Condition} => {item.Value}{comma}");
        }

        Close(false, appendClose);
    }

    public CodeWriterBase WriteLine(string text = "")
    {
        if (string.IsNullOrEmpty(text))
            Output!.WriteLine("");
        else
            Output!.WriteLine(IndentString + text);
        return this;
    }

    private string IndentString { get; set; } = string.Empty;

    private int _indent;

    protected TextTransformation? Output;
}

public abstract class PrimitiveObsessionBase(string name, string wrappedType) : CodeWriterBase
{
    public static void WriteAll<T>(T[] infos, TextTransformation p)
        where T : PrimitiveObsessionBase
    {
        var back = infos.Select(a => a.Implement).ToArray();
        foreach (var info in infos)
        {
            info.Implement |= Config.IncludeFeatures;
            info.Implement &= ~Config.IgnoreFeatures;

            if ((info.Implement & (Features.RelativeOperators | Features.ComparableObject)) != 0)
                info.Implement |= Features.Comparable;
        }

        var usings = infos
            .SelectMany(a => a.GetUsingNamespaces())
            .Distinct()
            .Where(a => !Config.ImplicitUsings.Contains(a))
            .OrderBy(a => a).ToArray();
        foreach (var ns in usings)
            p.WriteLine($"using {ns};");
        p.WriteLine("");

        p.WriteLine($"namespace {Config.Namespace};");
        p.WriteLine("");

        for (var index = 0; index < infos.Length; index++)
        {
            var info = infos[index];
            info.WriteCode(p);
            info.Implement = back[index];
        }
    }

    protected virtual void AddFieldsAndProperties()
    {
    }

    private void AddNewtosoftJsonConverter()
    {
        if ((Implement & Features.NewtonsoftJsonSerializer) == 0) return;
        Open($"public sealed class {Name}JsonConverter : JsonConverter");
        {
            WriteLine("public override bool CanConvert(Type objectType) => objectType == typeof(" + Name + ");");
            WriteLine();
            Open(
                "public override object? ReadJson(JsonReader reader, Type objectType, object? existingValue, JsonSerializer serializer)");

            WriteCaseExpressionStatement("return reader.Value switch", GetJsonConverterReadItems(), ";");
            Close(true);
            Open("public override void WriteJson(JsonWriter writer, object? value, JsonSerializer serializer)");
            {
                SingleLineIf("value is null",
                    "throw new NullReferenceException(\"value is null\");");
                WriteLine($"writer.WriteValue((({Name})value).Value);");
            }
            Close(true);
        }
        Close(true);
    }

    private void AddSystemTextJsonConverter()
    {
        if ((Implement & Features.SystemTextJsonSerializer) == 0) return;
        Open(
            $"public sealed class {Name}SystemTextJsonConverter : System.Text.Json.Serialization.JsonConverter<{Name}>");
        {
            Open(
                $"public override {Name} Read(ref System.Text.Json.Utf8JsonReader reader, Type typeToConvert, System.Text.Json.JsonSerializerOptions options)");
            WriteSystemTextConverter(true);
            // WriteLine($"return {Name}.Parse(reader.GetString()!);");
            Close(true);

            Open(
                $"public override void Write(System.Text.Json.Utf8JsonWriter writer, {Name} value, System.Text.Json.JsonSerializerOptions options)");
            //WriteLine("writer.WriteStringValue(value.Value.ToString());");
            WriteSystemTextConverter(false);
            Close(true);
        }
        Close(true);
    }

    protected void BoolOperator(string op, string expr)
    {
        WriteLine($"public static bool operator {op}({Name} left, {Name} right) => {expr};").WriteLine();
    }

    protected virtual string GetEqualsExpression(string a, string b)
    {
        return $"{a}.Equals({b})";
    }

    private IEnumerable<string> GetInterfaces()
    {
        if ((Implement & Features.PrimitiveWrapper) != 0)
            yield return $"IPrimitiveWrapper<{WrappedType}>";
        if ((Implement & Features.EquatablePrimitive) != 0)
            yield return $"IEquatable<{WrappedType}>";
        yield return $"IEquatable<{Name}>";
        if ((Implement & Features.ComparablePrimitive) != 0)
            yield return $"{nameof(IComparable)}<{WrappedType}>";
        if ((Implement & Features.Comparable) != 0)
            yield return $"IComparable<{Name}>";
        if ((Implement & Features.ComparableObject) != 0)
            yield return "IComparable";
    }

    protected abstract IEnumerable<CaseExpressionItem> GetJsonConverterReadItems();

    protected virtual string GetRelativeOperatorCode(string op, string left, string right)
    {
        return $"{left}.CompareTo({right}) {op} 0";
    }

    protected virtual IEnumerable<string> GetUsingNamespaces()
    {
        yield return "System";
        if ((Implement & Features.PrimitiveWrapper) != 0)
            yield return "iSukces.Base";
        if ((Implement & Features.NewtonsoftJsonSerializer) != 0)
            yield return "Newtonsoft.Json";
    }

    protected virtual string PrepareArgument(string variableName)
    {
        return variableName;
    }

    private void WriteAttributes()
    {
        if ((Implement & Features.NewtonsoftJsonSerializer) != 0)
            WriteLine($"[JsonConverter(typeof({Name}JsonConverter))]");
    }

    private void WriteCode(TextTransformation output)
    {
        Output = output;
        WriteAttributes();
        var record      = UseRecordStruct ? " record" : "";
        var constructor = UseRecordStruct ? $"({WrappedTypeRefNullable} Value)" : "";
        var part        = IsPartial ? " partial" : "";
        Open($"public readonly{record}{part} struct {Name}{constructor}: {Interfaces}");
        WriteCodeInternal();

        if (AllowWriteFromNullable)
            WriteLine($"public static {Name}? FromNullable({WrappedType}? value)")
                .IncIndent()
                .WriteLine($"=> value is null ? null : new {Name}(value.Value);")
                .DecIndent()
                .WriteLine();
        WriteToString();
        WriteTypeConversion();
        WriteRelativeOperators();
        WriteEqualityOperators();
        AddFieldsAndProperties();
        Close(true);
        AddNewtosoftJsonConverter();
        AddSystemTextJsonConverter();
    }

    protected abstract void WriteCodeInternal();

    private void WriteEqualityOperators()
    {
        if (UseRecordStruct || (Implement & Features.EqualityOperators) == 0)
            return;
        BoolOperator("==", "left.Equals(right)");
        BoolOperator("!=", "!left.Equals(right)");
    }

    protected void WriteIComparableAndEquatable(Func<string, string, string>? convertToComparable = null)
    {
        var arg = PrepareArgument("other");
        convertToComparable ??= (a, b) => $"{a}.CompareTo({b})";
        if ((Implement & Features.EquatablePrimitive) != 0)
            WriteLine($"public bool Equals({WrappedTypeRefNullable} other) => {GetEqualsExpression("Value", arg)};")
                .WriteLine();
        if ((Implement & Features.Comparable) != 0)
        {
            var c1 = convertToComparable("Value", "other.Value");
            WriteLine($"public int CompareTo({Name} other) => {c1};").WriteLine();
        }

        if ((Implement & Features.ComparableObject) != 0)
        {
            //var c1 = convertToComparable("Value", arg);
            Open("public int CompareTo(object? obj)")
                .WriteLine("if (obj is null) return 1;")
                .WriteLine($"return obj is {Name} other")
                .IncIndent()
                .WriteLine("? CompareTo(other)")
                .WriteLine($": throw new ArgumentException($\"Object must be of type {{nameof({Name})}}\");")
                .DecIndent()
                .Close(true);
        }

        if ((Implement & Features.ComparablePrimitive) != 0)
        {
            var c1 = convertToComparable("Value", arg);
            WriteLine($"public int CompareTo({WrappedTypeRefNullable} other) => {c1};")
                .WriteLine();
        }
    }

    private void WriteRelativeOperators()
    {
        if ((Implement & Features.RelativeOperators) == 0) return;

        foreach (var op in "> < >= <=".Split(' '))
            BoolOperator(op, GetRelativeOperatorCode(op, "left", "right"));
    }

    protected abstract void WriteSystemTextConverter(bool reader);

    /// <summary>
    ///     ToString method expression
    /// </summary>
    public static string? ToStringExpression { get; set; }

    private void WriteToString()
    {
        var expr = Config.ToStringExpression;
        if (!string.IsNullOrEmpty(ToStringExpression))
            expr = ToStringExpression;
        if (string.IsNullOrEmpty(expr)) return;
        WriteLine($"public override string ToString() => {expr};")
            .WriteLine();
    }

    private void WriteTypeConversion()
    {
        Write(ConvertFromPrimitive, Name, WrappedTypeRefNullable, $"new {Name}(value)");
        Write(ConvertToPrimitive, WrappedType, Name, "value.Value");
        return;

        void Write(TypeConversion c, string result, string arg, string expression)
        {
            if (c == TypeConversion.None) return;

            WriteLine(
                    $"public static {ConvertToPrimitive.ToString().ToLower()} operator {result}({arg} value) => {expression};")
                .WriteLine();
        }
    }

    protected bool UseRecordStruct           { get; set; } = true;
    protected bool AllowWriteFromNullable    { get; set; } = true;
    protected bool HasReferenceNullableValue { get; set; }
    public    bool IsPartial                 { get; set; }

    public TypeConversion ConvertToPrimitive   { get; set; } = Config.ConvertToPrimitive;
    public TypeConversion ConvertFromPrimitive { get; set; } = Config.ConvertFromPrimitive;

    public string Name { get; } = name;

    public string Interfaces
        => string.Join(", ", GetInterfaces().OrderBy(a => a).Distinct());

    public string WrappedType { get; } = wrappedType;

    public string WrappedTypeRefNullable => HasReferenceNullableValue ? $"{WrappedType}?" : WrappedType;

    public Features Implement { get; set; }
}

public class IntKey(string name) : PrimitiveObsessionBase(name, "int")
{
    protected override string GetEqualsExpression(string a, string b)
    {
        return $"{a} == {b}";
    }

    protected override IEnumerable<CaseExpressionItem> GetJsonConverterReadItems()
    {
        var parse = (Implement & Features.Parse) != 0
            ? $"{Name}.Parse(stringValue)"
            : $"new {Name}({WrappedType}.Parse(stringValue.Trim()), CultureInfo.InvariantCulture)";
        yield return new CaseExpressionItem("string stringValue", parse);
        yield return new CaseExpressionItem("int intValue", $"new {Name}(intValue)");
        yield return new CaseExpressionItem("long longValue", $"new {Name}(({WrappedType})longValue)");
        yield return new CaseExpressionItem($"null when objectType == typeof({Name}?)", "null");
        yield return new CaseExpressionItem("null", "throw new NotImplementedException()");
        yield return new CaseExpressionItem("_", "throw new NotImplementedException()");
    }

    protected override string GetRelativeOperatorCode(string op, string left, string right)
    {
        return $"{left}.Value {op} {right}.Value";
    }

    protected override IEnumerable<string> GetUsingNamespaces()
    {
        foreach (var ns in base.GetUsingNamespaces())
            yield return ns;
        if ((Implement & (Features.NewtonsoftJsonSerializer | Features.Parse)) != 0)
            yield return "System.Globalization";
        if ((Implement & (Features.SystemTextJsonSerializer | Features.Parse)) != 0)
            yield return "System.Globalization";
    }

    protected override void WriteCodeInternal()
    {
        WriteIComparableAndEquatable();
        WriteParse();
    }

    private void WriteParse()
    {
        if ((Implement & Features.Parse) == 0) return;
        Open($"public static {Name} Parse(string? text)");
        WriteLine("text = text?.Trim();");
        CheckArgumentNullOrEmpty("text");
        WriteLine($"return new {Name}({WrappedType}.Parse(text, CultureInfo.InvariantCulture));");
        Close(true);
    }

    protected override void WriteSystemTextConverter(bool reader)
    {
        if (reader)
            WriteLine($"return new {Name}(reader.GetInt32());");
        else
            WriteLine("writer.WriteNumberValue(value.Value);");
    }
}

public class StringKey : PrimitiveObsessionBase
{
    public StringKey(string name, StringComparison comparison = StringComparison.Ordinal)
        : base(name, "string")
    {
        UseRecordStruct           = false;
        AllowWriteFromNullable    = false;
        HasReferenceNullableValue = true;
        WithComparison(comparison);
    }

    protected override void AddFieldsAndProperties()
    {
        base.AddFieldsAndProperties();

        WriteLine($"private readonly {WrappedTypeRefNullable} _value;");
        WriteLine();

        WriteLine($"public {WrappedType} Value => _value ?? string.Empty;");
        WriteLine();

        WriteLine($"public static {Name} Empty {{ get; }} = new {Name}(null);");
        WriteLine();

        WriteLine("public bool IsEmpty => string.IsNullOrEmpty(_value);");
        WriteLine();

        WriteLine($"public static StringComparer {ComparerPropertyName} => {Comparer};");
        WriteLine();
    }

    protected override string GetEqualsExpression(string a, string b)
    {
        return $"{ComparerPropertyName}.Equals({a}, {b})";
    }

    protected override IEnumerable<CaseExpressionItem> GetJsonConverterReadItems()
    {
        yield return new CaseExpressionItem("string stringValue", $"new {Name}(stringValue)");
        yield return new CaseExpressionItem("null", $"{Name}.Empty");
        yield return new CaseExpressionItem("_", "throw new NotImplementedException()");
    }

    protected override string PrepareArgument(string variableName)
    {
        return $"{variableName} ?? string.Empty";
    }

    public StringKey WithComparison(StringComparison comparison)
    {
        Comparer = "StringComparer." + comparison;
        return this;
    }

    protected override void WriteCodeInternal()
    {
        var text = string.Format(StringPreprocess, "value");
        WriteLine($"public {Name}({WrappedTypeRefNullable} value) => _value = {text};");
        WriteLine();

        WriteLine($"public override bool Equals(object? obj) => obj is {Name} x && Equals(x);")
            .WriteLine();

        WriteLine($"public bool Equals({Name} other) => {GetEqualsExpression("Value", "other.Value")};")
            .WriteLine();

        WriteLine($"public override int GetHashCode() => {ComparerPropertyName}.GetHashCode(Value);")
            .WriteLine();

        WriteIComparableAndEquatable((a, b) => $"{ComparerPropertyName}.Compare({a}, {b})");
    }

    protected override void WriteSystemTextConverter(bool reader)
    {
        if (reader)
            WriteLine($"return new {Name}(reader.GetString());");
        else
            WriteLine("writer.WriteStringValue(value.Value);");
    }

    public string Comparer { get; set; } = "StringComparer.Ordinal";

    public string StringPreprocess { get; set; } = "{0}?.Trim()";

    private const string ComparerPropertyName = "Comparer";
}

public class GuidKey(string name) : PrimitiveObsessionBase(name, "Guid")
{
    protected override void AddFieldsAndProperties()
    {
        base.AddFieldsAndProperties();
        WriteLine($"public static {Name} Empty {{ get; }} = new {Name}(Guid.Empty);");
        WriteLine();
        WriteLine("public bool IsEmpty => Value.Equals(Guid.Empty);");
        WriteLine();
    }

    protected override IEnumerable<CaseExpressionItem> GetJsonConverterReadItems()
    {
        var parse = (Implement & Features.Parse) != 0
            ? $"{Name}.Parse(stringValue)"
            : $"new {Name}({WrappedType}.Parse(stringValue.Trim()))";
        yield return new CaseExpressionItem("string stringValue", parse);
        yield return new CaseExpressionItem($"null when objectType == typeof({Name}?)", "null");
        yield return new CaseExpressionItem("null", "throw new NotImplementedException()");
        yield return new CaseExpressionItem("_", "throw new NotImplementedException()");
    }

    protected override void WriteCodeInternal()
    {
        WriteIComparableAndEquatable();
        WriteParse();
        WriteLine($"public static {Name} NewUid() => new {Name}(Guid.NewGuid());");
        WriteLine();
    }

    private void WriteParse()
    {
        if ((Implement & Features.Parse) == 0) return;
        Open($"public static {Name} Parse(string? text)");
        WriteLine("text = text?.Trim();");
        CheckArgumentNullOrEmpty("text");
        WriteLine($"return new {Name}({WrappedType}.Parse(text));");
        Close(true);
    }

    protected override void WriteSystemTextConverter(bool reader)
    {
        if (reader)
            WriteLine($"return {Name}.Parse(reader.GetString()!);");
        else
            WriteLine("writer.WriteStringValue(value.Value.ToString());");
    }
}

public class DoubleKey(string name) : PrimitiveObsessionBase(name, "double")
{
    protected override void AddFieldsAndProperties()
    {
        base.AddFieldsAndProperties();
        WriteLine($"public static {Name} Empty {{ get; }} = new {Name}(double.NaN);");
        WriteLine();
        WriteLine("public bool IsEmpty => double.IsNaN(Value);");
        WriteLine();
    }

    protected override IEnumerable<CaseExpressionItem> GetJsonConverterReadItems()
    {
        var parse = (Implement & Features.Parse) != 0
            ? $"{Name}.Parse(stringValue)"
            : $"new {Name}({WrappedType}.Parse(stringValue.Trim()))";
        yield return new CaseExpressionItem("decimal decimalValue", $"new {Name}((double)decimalValue)");
        yield return new CaseExpressionItem("double doubleValue", $"new {Name}(doubleValue)");
        yield return new CaseExpressionItem("long longValue", $"new {Name}(longValue)");
        yield return new CaseExpressionItem("string stringValue", parse);
        yield return new CaseExpressionItem($"null when objectType == typeof({Name}?)", "null");
        yield return new CaseExpressionItem("null", "throw new NotImplementedException()");
        yield return new CaseExpressionItem("_", "throw new NotImplementedException()");
    }

    protected override IEnumerable<string> GetUsingNamespaces()
    {
        var a = base.GetUsingNamespaces().ToList();
        if ((Implement & Features.Parse) != 0)
            a.Add("System.Globalization");
        return a;
    }

    protected override void WriteCodeInternal()
    {
        WriteIComparableAndEquatable();
        WriteParse();
    }

    protected override void WriteSystemTextConverter(bool reader)
    {
        if (reader)
            WriteLine($"return {Name}.Parse(reader.GetString()!);");
        else
            WriteLine("writer.WriteStringValue(value.Value.ToString());");
    }

    private void WriteParse()
    {
        if ((Implement & Features.Parse) == 0) return;
        Open($"public static {Name} Parse(string? text)");
        WriteLine("text = text?.Trim();");
        CheckArgumentNullOrEmpty("text");
        WriteLine($"return new {Name}({WrappedType}.Parse(text, NumberStyles.Any, CultureInfo.InvariantCulture));");
        Close(true);
    }
}

#>
